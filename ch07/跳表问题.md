# #跳表问题

## ##算法思想

1.跳表的结构体

struct skip_list_node
{
	/*key是唯一的*/
	int key;       
	/*存储的内容*/
	int value;     
	/*当前节点最大层数*/
	int max_level; 
	/*柔性数组,根据该节点层数的不同指向大小不同的数组
	 *next[0]表示该节点的第一层下一节点的索引地址
	 *next[1]表示该节点的第二层下一节点的索引地址
	 *next[n]表示该节点的第n层下一节点的索引地址
	 */
	struct skip_list_node *next[];
};

struct skip_list
{
	int level; /*跳表的索引层数*/
	int num;   /*节点数目*/

​    struct skip_list_node *node；

}；

2.跳表的初始化：只初始化head和end结点

3.跳表的搜索

① 从收割head节点的有效层数的最高层开始，从左往右搜索，直至找到一个大于或等于目标的元素，或者到达当前层链表的尾部。

② 如果该元素等于目标元素，则表明该元素已被找到。

③ 如果该元素大于目标元素或已到达链表的尾部，则退回到当前层的前一个元素，然后转入下一层进行搜索。

4.跳表的添加

① 根据跳表搜索的方式确定节点添加的位置

- a：如果已经存在这个节点，则覆盖
- b: 如果不存在，则应该找到第一个大于这个需要新添加的节点的位置

② 随机决定新添加元素的层数

5.跳表的删除

① 根据跳表搜索的方式确定节点删除的位置，如果已经存在这个节点，则删除

② 删除一个元素后，这个元素的所有前驱节点指向这个节点的所有后继节点

③ 删除一个元素后，整个跳表的层数可能会降低